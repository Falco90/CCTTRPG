'use client'

import lighthouse from '@lighthouse-web3/sdk';
import { useState } from 'react'
import { useWeb3Modal } from '@web3modal/wagmi/react'
import { useAccount } from 'wagmi'
import { useEffect } from 'react'
import { getEthersSigner } from "./utils/ethers"
import { createWalletClient, custom } from 'viem'
import { mainnet, scrollSepolia } from 'viem/chains'

function UploadFileComponent() {
    const [item, setItem] = useState({
        name: "",
        cid: ""
    });
    const [cid, setCid] = useState("")
    const [file, setFile] = useState(null)
    const { address } = useAccount()
    const [signer, setSigner] = useState(null)


    const client = createWalletClient({
        chain: scrollSepolia,
        transport: custom(window.ethereum)
    })

    useEffect(() => {
        if (address) {
            getSigner()
        }

    }, [address])

    async function getSigner() {

        const signer = await getEthersSigner({ chainId: 534351 })
        setSigner(signer)
    }

    const progressCallback = (progressData) => {
        let percentageDone =
            100 - (progressData?.total / progressData?.uploaded)?.toFixed(2);
        console.log(percentageDone);
    };

    async function uploadFile(file) {
        const apiKey = process.env.NEXT_PUBLIC_LIGHTHOUSE_API_KEY
        const output = await lighthouse.upload(file, apiKey, false, null, progressCallback);
        console.log('File Status:', output);

        console.log('Visit at https://gateway.lighthouse.storage/ipfs/' + output.data.Hash);
    }

    const uploadEncryptedText = async (progressCallback) => {
        const messageRequested = (await lighthouse.getAuthMessage(address)).data
            .message;

        const signedMessage = await signer.signMessage(messageRequested);

        const json = {
            name: "Test name",
            text: " dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in"
        } 
        await lighthouse.textUploadEncrypted(
            json,
            process.env.NEXT_PUBLIC_LIGHTHOUSE_API_KEY,
            address,
            signedMessage,
            "test name"
        ).then((response) => {
            setCid(response.data.Hash)
        });

        //write to smart contract create item function
        // client.writeContract()

    }

    async function shareFile() {
        try {
            // CID of the encrypted file that you want to share
            // CID is generated by uploading a file with encryption
            // Only the owner of the file can share it with another wallet address
            const messageRequested = (await lighthouse.getAuthMessage(address)).data
                .message;

            const signedMessage = await signer.signMessage(messageRequested);

            const publicKey = address
            const publicKeyUserB = "0xA55fA7426FD00ae3f34411F82D90dC6420E32160"

            const shareResponse = await lighthouse.shareFile(
                publicKey,
                [publicKeyUserB],
                cid,
                signedMessage
            );
        } catch (error) {
            console.log(error);
        }
    }

    return (
        <div>
            <p>Upload Asset</p>
            <input onChange={e => uploadFile(e.target.files)} type="file" />
            <p>Upload Encrypted</p>
            <button onClick={() => uploadEncryptedText()} type="file">Upload text</button>
            {cid}
            <button onClick={() => shareFile()} type="file">Share File</button>
        </div>
    )
}

export default UploadFileComponent;